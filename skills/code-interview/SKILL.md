---
name: code-interview
description: 项目代码面试文档生成器。系统性地梳理项目发展历史，通过Git记录分析、文档挖掘和代码分析，输出两份专业文档：(1) 完整变更历史文档 - 追溯项目演进逻辑、决策背景和技术选型 (2) 重难点专题文档 - 聚焦跨模块架构调整、高技术难点、历史遗留问题和核心业务链路。用于代码面试准备、新人入职项目理解、技术债梳理和架构回顾。
---

# Code Interview

## Overview

系统性地梳理项目发展历史，输出两份专业文档帮助理解项目演进：

- **文档A：完整变更历史** - 追溯每个重大决策的来龙去脉，包含背景、原因、实现细节、效果、风险和优化方向
- **文档B：重难点专题** - 聚焦跨模块架构调整、高技术难点、历史遗留问题和核心业务链路

## Workflow

```
第一阶段：信息收集与结构化
│
├─ 步骤1：Git记录分析
│  └─ 提取重大变更提交（功能/重构/性能/安全/架构）
│
├─ 步骤2：项目文档挖掘
│  └─ 从README/设计文档/API文档/架构决策记录提取
│
├─ 步骤3：代码实现细节分析
│  └─ 分析代码结构/注释/依赖还原实现层变更
│
├─ 步骤4：信息归并
│  └─ 统一数据模型，合并去重，时间排序
│
└─ 步骤5：缺失信息补全
   └─ 基于代码逻辑合理推断（标记[推断]）

第二阶段：文档生成
│
├─ 文档A：完整变更历史
│  └─ 按时间倒序，每个变更含6个模块
│
└─ 文档B：重难点专题
   └─ 按模块组织，每个难点含4个模块
```

## 第一阶段：信息收集与结构化

### 步骤1：Git记录分析

若项目使用Git，读取commit记录。仅提取**重大变更或关键优化**的提交。

使用 `git log` 命令获取提交历史：
```bash
git log --all --pretty=format:"%H|%ai|%s" --reverse
```

**过滤标准**（满足其一）：
- 新功能开发（feature、add、implement）
- 重构（refactor、rework、rewrite）
- 性能优化（performance、optimize、speedup）
- 安全修复（security、fix、vulnerability）
- 架构调整（architecture、restructure）
- 依赖升级（upgrade、update、migrate）

每条记录必须标注：
- **时间**：提交日期（YYYY-MM-DD）
- **模块**：所属子系统/组件名
- **变更类型**：功能/重构/性能/安全/架构/测试/文档/其他
- **标题**：提交信息标题
- **影响范围**：涉及的文件/模块
- **commit id**（可选）：完整或短哈希

### 步骤2：项目文档挖掘

扫描项目中的文档文件：
- README.md、CONTRIBUTING.md
- docs/ 目录下的所有文档
- 设计文档、API文档
- 架构决策记录（ADR）
- CHANGELOG、会议纪要

提取其中明确描述的：
- 重大变更说明
- 架构调整决策
- 技术选型理由
- 弃用/迁移说明

每条记录必须标注：
- **时间**（或版本）：文档日期或版本号
- **模块**：所属子系统/组件名
- **变更类型**：功能/重构/性能/安全/架构/文档/其他
- **标题**：变更/决策的标题
- **详细描述**：背景、原因、实现思路、效果
- **文档路径**：源文件路径

### 步骤3：代码实现细节分析

通过以下线索还原实现层面的重大变更：

**分析维度**：
- 代码结构变化（新增/删除/重构类/函数）
- 关键注释中的变更说明
- 模块依赖关系变化
- 废弃API/配置项
- 测试用例的增删改
- 数据库Schema变更（migration文件）
- 包依赖变化（package.json、requirements.txt等）

每条记录必须包含：
- **变更前代码特征**：类/方法/配置名称
- **变更后代码特征**：新的类/方法/配置名称
- **核心改动点描述**：实现思路、算法变化、数据结构变化
- **关联文件路径**：受影响的文件列表
- **代码片段示例**（可选）：关键代码示例

### 步骤4：信息归并

将前三步收集的所有记录按**统一数据模型**合并、去重、时间排序：

**统一字段结构**：
```yaml
时间: YYYY-MM-DD（提交时间/文档日期/推测时间）
模块: 所属子系统/组件名
变更类型: 功能/重构/性能/安全/架构/测试/文档/其他
标题: 一句话概括变更内容
详细描述: 背景、原因、实现思路、效果等
关联资源:
  - commit_id: "abc123"  # Git提交哈希
  - doc_path: "docs/architecture.md"  # 文档路径
  - code_paths: ["src/main.py", "src/utils.py"]  # 代码文件路径
补充信息源: git/文档/代码分析  # 用于追溯
```

**归并规则**：
- 同一变更的多条来源合并为一条记录
- commit id、文档路径、代码路径都记录在`关联资源`中
- 按时间升序排序（最早的在前）
- 时间缺失时标记为`[未知时间]`并尝试从上下文推断

### 步骤5：缺失信息补全规则

**仅在以上三步无法获取时启用**。若某条变更记录的关键信息缺失（如背景、原因、效果），允许基于以下原则进行合理推断并标记。

**推断依据优先级**：
1. 项目当前代码逻辑与注释
2. 项目业务场景与用户故事
3. 常见技术决策模式
4. 变更后明显修复的问题或带来的收益

**禁止事项**：
- 禁止凭空捏造不存在的变更
- 推断内容必须与项目实际代码/文档语境兼容

**标记格式**：
```
[推断] 为提升列表查询性能，引入Redis缓存（理由：cache目录新增redis.py）
```

**适用字段**：
- `背景`：从代码结构/业务逻辑推断
- `原因`：从问题类型/技术选型推断
- `效果`：从代码变化/性能特征推断

## 第二阶段：文档生成

### 文档A：完整变更历史

**用途**：帮助追溯项目演进逻辑，理解每个决策的来龙去脉。

**收录范围**：第一阶段中所有被判定为"重大变更或优化"的记录。

**文档结构**：
```markdown
# 项目变更历史

## 概览
- 总变更数：X条
- 时间跨度：YYYY-MM-DD 至 YYYY-MM-DD
- 主要模块：模块A、模块B、模块C

## 变更详情

### [YYYY-MM-DD] 变更标题

**基本信息**
- 模块：XXX
- 变更类型：功能/重构/性能/安全/架构
- 关联资源：commit abc123 / docs/architecture.md

#### ①背景
变更前的状态、业务痛点、技术债或用户反馈。
（缺失时使用[推断]标记）

#### ②原因
为什么选择此时变更？为什么选择此方案？
如：性能瓶颈达阈值、安全漏洞披露、技术栈到期等。

#### ③代码细节
核心实现思路、关键代码片段（类/方法级）、配置变化、数据库迁移脚本等。

#### ④效果
量化收益优先（如QPS提升30%、内存占用降低50%）；
若无数据则描述定性改善（如代码可读性、扩展性）。

#### ⑤风险
引入的兼容性问题、潜在Bug、回滚计划、已知缺陷。

#### ⑥下一步优化方向
- 未完成的构想
- 待重构点
- 更优的替代技术方案

---

### [YYYY-MM-DD] 另一个变更标题
...
```

**格式建议**：
- 按时间**倒序**排列（最新的在前）
- 每个变更以 `### [YYYY-MM-DD] 变更标题` 开头
- 清晰分层，便于导航

### 文档B：重难点专题

**用途**：帮助快速攻克项目中最复杂的模块或历史技术债。

**收录标准**（满足其一）：

1. **跨模块架构调整**：影响范围大、涉及多个子系统
2. **高技术难度**：涉及复杂算法、并发控制、存储选型
3. **历史遗留问题**：反复修改、技术债累积严重
4. **业务核心链路**：对可用性/一致性要求极高

**文档结构**：
```markdown
# 重难点专题

## 目录
1. [模块A：分布式事务实现](#模块a分布式事务实现)
2. [模块B：高并发缓存策略](#模块b高并发缓存策略)
...

---

## 模块A：分布式事务实现

### ①背景
**为何成为难点**：
- 业务复杂：需要协调多个服务的数据一致性
- 历史债务：早期采用单机事务，后拆分为微服务
- 技术选型约束：需要兼容现有数据库

**问题表现**：
- 数据不一致频率：约X次/天
- 用户体验影响：订单异常率X%

### ②解决方案

**实现思路**：
采用Saga模式实现分布式事务协调...

**架构示意**：
```
[订单服务] --> [库存服务] --> [支付服务]
    |              |              |
    └────[协调器]─────────────────┘
         (补偿事务管理)
```

**关键代码**：
```python
class SagaCoordinator:
    def execute(self, transactions):
        # 执行正向事务
        for tx in transactions:
            if not tx.execute():
                # 执行补偿
                self.compense(transactions)
                return False
        return True
```

**配置示例**：
```yaml
saga:
  timeout: 30s
  retry_policy:
    max_attempts: 3
    backoff: exponential
```

### ③实现效果

**解决的问题**：
- 数据一致性：从99.5%提升至99.99%
- 订单异常率：从X%降至Y%

**遗留问题**：
- 补偿事务失败时仍需人工介入
- 长事务场景性能较慢

### ④未来展望

**若重新设计**：
在当前技术环境下，可考虑：
- 采用事件溯源（Event Sourcing）模式
- 使用成熟的分布式事务框架（如Seata）

**替代方案**：
- 从消息队列半一致性转向最终一致性
- 引入CRDT（无冲突复制数据类型）

**关联变更**：[2024-03-15] 引入Saga模式、[2024-05-20] 补偿事务优化

---

## 模块B：高并发缓存策略
...
```

**格式建议**：
- 按模块或时间顺序组织
- 每个重难点独立章节
- 附"关联变更ID"链接到文档A

## 输出规范

1. **文件命名**：
   - 文档A：`项目名_变更历史.md`
   - 文档B：`项目名_重难点专题.md`

2. **目录结构**：
```
project-analysis/
├── 项目名_变更历史.md
├── 项目名_重难点专题.md
└── sources/
    ├── git_commits.json     # Git原始数据
    ├── docs_extracted.json  # 文档提取数据
    └── code_analysis.json   # 代码分析数据
```

3. **质量检查**：
   - 每条重大变更的6个模块是否完整
   - 推断内容是否正确标记[推断]
   - 代码示例是否准确
   - 日期排序是否正确
